PART 1;

1. a. CPU sockets - 1
      CPU cores (per CPU)  - 4
      Num of CPUs - 4

   b. Frequency of each CPU - 2032.148 Mhz, 2215.664 Mhz, 2283.046 Mhz, 2297.226 Mhz

   c. Total Memory Available - 8145028 kB

   d. Free memory - 4458228 kB
      Available Memory - 5700932 kB
      Free memory is the physical RAM memory which is avaiable currently whereas Available Memory is an estimate of memory available to start new applications considering things like Cache memory.

   e. Total number - 283 (Each numbered directory in /proc/ corresponds to a separate process or alternatively we can find using ps -A)

   f. Total number of context switches - 41669859 (/proc/stat)

   g. The size of the files is shown to be zero. The reason for this must be that these are not actual files in the memory but are generated by running approproate calls to the kernal in the OS.



2. memory1 - VmSize = 8140 kB, VmRSS = 680 kB
   memory2 - VmSize = 12044 kB, VmRSS = 724 kB
   memory3 - VmSize = 8140 kB, VmRSS = 3132 kB
   memory4 - VmSize = 8140 kB, VmRSS = 5248 kB

   Here VmSize is the total virtual memory size and VmRSS is how much of this memory is resident in physical memory. Comparing first two it is clear that VmSize (as well as VmRSS) increases in the second case as the size of the array is bigger in the 2nd program. In the 3rd and 4th program the total VmSize remains same as in the 1st case as the size of the array is same. But it is clear that VmSize of 3rd is more than that of 1st since half the elements in the array have been assigned which forces the program to make more of its virtual memory to be resident. Similary the resident memory is more in the 4th case than 3rd since all the array elements have been assigned.

3. Number of child processes created = 22. We can find this using the ps command - Specifically ps ppid gives the id of the parent process. We then use grep with the corresponding parent pid and use 'wc -l' to count the total number. (Also just using grep with the process name in ps gives 23 count which is the parent process plus number of children parents)

4. The output of strace shows the different function used by the executable 'empty'. We see a total of 12 different functions which are called by the first executable 'empty'.
   a. All the function calls upto the munmap() are common to both. There is directly the exit_group() in the first case whereas there are more function calls in the second case before exit_group() which are specific to the program.
   b. The function calls unique to hello.c are: getpid(), write() and lseek(). The function calls which are common to both include - access(), read(), open(), mmap(), mprotect(), execve(), fstat() etc.

5. The executable opens 6 files (although 3 of them point to the same file) - /dev/pts/17, /tmp/welcome to OS, /tmp/CS333, and /tmpCS347. This can be obtained by first finding pid of 'opefiles' using ps -A | grep "openfiles" and then using the pid in the losf commad - lsof -p pid

6. The block devices can be found using lsblk command. There is one block device - sda (disk) which has been divided into parts sda1, sda2 and sda3 with their correspoinding mount points.
   (Command : lsblk)



PART 2:


7. In the first case QEMU is not able to boot and hence gives an error. The reason for this is that there is no magic number added as the last two bytes whereas they have been added in the second case - thus we do not get an error in the second case.

8.  Done in part2/hello.asm
